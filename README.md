# MarkovAlgorithm
Interpreter for the Markov algorithm
Интерпретатор протоколов нормального алгортма Маркова.

1. Формат ыходных данных.

Данные необходимо подготовить в следующем формате.

Все строки, кроме последней, задают СХЕМУ алгортма.
Строки схемы, НЕ СОДЕРЖАЩИЕ биграммы "->" игнорируются.
Части строк, лежащие правее биграммы "//" и сама биграмма "//" игнорируются.
И то и другое можно использовать для записи комментариев к схеме.

Пробелы в схеме игнорируются.

Каждая строка с биграммой "->" в схеме (после отбрасывание игнорируемых частей строки)
задает ОДНО правило схемы.

При этом символы левее "->" являются левой частью правила.
Символы правее "->" являются правой частью правила, кроме ПОСЛЕДНЕГО символа "x"
(латинский символ х нижнего регистра), если он есть.
Если последним ЗНАЧАЩИМ символом строки правила является символ "х",
то данное правило является ЗАВЕРШАЮЩИМ правилом схемы.
То есть для завершающего правила правой частью будут все символы правее "->" 
и ЛЕВЕЕ ПОСЛЕДНЕГО "х".

Допускаются правила с ПУСТЫМИ левыми и/или правыми частями,
когда поле удаления незначащих символов левее и/или правее "->"
не остается ничего, возможно, кроме последнего "x".

Правила в схеме упорядочиваются по их порядку во входных данных
и в листинге протокола нумеруются от 1.

Последняя строка своей значащей частью (после удаления пробелов и комментариев)
рассматривается как ИСХОДНОЕ СЛОВО ДЛЯ ПРИМЕНЕНИЯ АЛГОРИТМА.

Во входных данных используйте 8-битную кодировку символов, например, cp 1251.
Строки разделяйте парой символов ВОЗВРАТ_К_НАЧАЛУ_СТРОКИ и ПЕРЕХОД_НА_НОВУЮ_СТРОКУ:
символы с кодами 13 и 10 (десятичные), как это принято на платформах Windows.

Последняя строка это та строка, которая непосредственно примыкает к концу входных
данных, например, к концу файла, если Вы заранее готовите данные в виде файла.

При интерактивной работе со стандартного ввода программы-интерпретатора строки
разделяйте средствами ввода (например, нажатием клавиши Enter), а для формирования
признака конца ввода после ввода последней строки (нажатия Enter), создайте
условие конца файла, например, нажмите сочетание клавиш Ctrl+D и затем Enter.

Для подачи данных на вход программе используйте либо буфер обмена, либо переназначьте
стандартный ввод на файл. Например, во многих командных интерпретаторах, например,
в cmd на Windows платформе, при запуске программ из командной строки символ "<"
(знак меньше) указывает назанчить ввод из файла, имя которого следует после этого символа.

Пример подготовленных данных:
==================================НАЧАЛО============================
// Удвоение в унарном коде из |
// * - вспомогательный символ

 *| ->  ||*   // Удвоение |
 *  ->  x     // Завершающая подстановка, чтобы не удвоить удвоенное
    ->  *     // Ставим * в начале строки

// Пример: удвоить 3 символа | (задается строка |||):

|||
==================================КОНЕЦ=============================

В данной схеме три правила.
Правило 1 меняет строку "*|" на строку "||*". Это правило не является завершающим.
Правило 2 меняет строку "*" на пустую. Это правило является завершающим.
Правило 3 меняет пустую строку на строку "*". Это правило не является завершающим.
Схема будет применяться с слову "|||".


2. Выводимый протокол.

Протокол выводится на стандартный вывод.
Используйте переназначение для его захвата в файл, например, укажите символ ">"
(знак больше) и далее имя файла при запуске из командной строки.

В начале протокола выводится ЛИСТИНГ СХЕМЫ.
Каждая строка листинга соответсвует одному правилу.
Строка начинается с присвоенного номера, за котрым ставится символ ":".
Далее через пробел выводится левая часть правила,
далее через пробел биграмма "->" и далее правая часть правила.
Если правило было помечено признаком завершающего правила, то в конце строки выводится
симлол "x".
Далее после символов "--- :" выводится слово, к которому будет применяться алгоритм.

Далее выводится собственно протокол.
На каждой итерации выводтся слово до внесения замен.
Под ним с необходимым числом пробелов слева выводится ЧАСТЬ слова, которая будет заменена.
Далее между символами "-" и "->" выводится НОМЕР ПРАВИЛА СХЕМЫ, в соответсвии с которым
происходит замена и далее строка, на которую ЭТИ СИМВОЛЫ меняются.
То есть выводятся левые и правые части некоторого правила, возможно пустые.

Например, если в слове "abcdefcdg" часть "cd" (первая слева) меняется на "xyz" по правилу 4,
то в протокол выводтися:

abcdefcdg
  cd -4-> xyz

Перед "cd" во второй строке выведено два пробела, так как первой слева подстроке "cd"
предшествует подстрока "ab" длиной два символа.

В результате замены получается слово "abxyzefcdg", которое будет выведено на следующей итерации,
если она возможна.

Возможность применения итерации определяется наличием в схеме правил, имеющих в левых частях
подстроки текущей строки (начальной или полученной на предыдущей итерации).
При этом полагается, что правило, примененное на предыдущей итерации не было помечено как Завершающее.

Заканчивается интерпретация тремя способами

(1) К текущему слову не применимо ни одно правило схемы.
    В этом случае в протокол выводится сообщение "***__NO_MORE_RULES__***".
    Это нормальное завершение.
    
(2) Было применено завершающее правило (помеченное "x").
    В этом случае выводится сообщение "***__FINAL_RULE__***".
    Это нормальное завершение.
    
(3) Получаемое слово достигло или превысит длину в 255 символов.
    В этом случае выводится сообщение "***__OVERFLOW__***".
    Это аварийное завершение, так как текущая реализация не сможет
    вывести очерепдное слово в протокол и продолжить интерпретацию.
    
В случаях (1) и (2) после сообщения о нормальном завершении
выводится полученное слово - результат применения схемы к начальному слову.
    
Пример для ввода
==================================НАЧАЛО============================
// Удвоение в унарном коде из |
// * - вспомогательный символ

 *| ->  ||*   // Удвоение |
 *  ->  x     // Завершающая подстановка, чтобы не удвоить удвоенное
    ->  *     // Ставим * в начале строки

// Пример: удвоить 3 символа | (задается строка |||):

|||
==================================КОНЕЦ=============================

вывод будет иметь вид
==================================НАЧАЛО============================
  1 : *| -> ||*
  2 : * ->  x
  3 :  -> *

--- : |||

|||
 -3-> *
*|||
*| -1-> ||*
||*||
  *| -1-> ||*
||||*|
    *| -1-> ||*
||||||*
      * -2-> 
***__FINAL_RULE__***

||||||
==================================КОНЕЦ=============================

Обратите внимание, что применение правила 3 это вставка "*" в начало строки
(замена ПУСТОЙ подстроки на подстроку "*"), а применение правила 2 это
удаление "*" (замена подстроки "*" на ПУСТУЮ).
